{"version":3,"sources":["logo.svg","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","isStart","isFinish","row","isVisited","col","isWall","onMouseDown","onMouseEnter","onMouseUp","extractClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","sort","nodeA","nodeB","maxCol","maxRow","startNode_row","startNode_col","finishNode_row","finishNode_col","window","screen","width","PathfindingVisualizer","animateShortestPath","nodesInShortestPath","i","setTimeout","document","getElementById","animateDijkstra","setState","message","clear","running","newGrid","initializeGrid","console","log","visualiseDijkstra","shortestPathOrder","getShortestPathOrder","mouseIsPressed","slice","newNode","currentRow","currentNode","previouNode","onClick","style","margin","map","rowIndx","nodeIndx","test","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.00a6d1a8.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React,{Component} from 'react';\nimport './Node.css';\n\nexport default class Node extends Component{\n    constructor(props){\n        super(props);\n        this.state={\n\n        }\n    }\n    \n    render(){\n        const {\n            isStart,\n            isFinish,\n            isVisited,\n            row,\n            col,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            // onClick\n        }=this.props;\n        const extractClassName=isFinish?'node-finish'\n                                :isStart?'node-start'\n                                :isWall?'node-wall':'';\n        return <div \n        id={`node-${row}-${col}`}\n        className={`node ${extractClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        // onClick={()=>onClick(row,col)}\n        ></div>\n    }\n    \n}","export function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (!!unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n\n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n\n  export function getShortestPathOrder(finishNode){\n      let {previousNode}=finishNode;\n      const shortestPathOrder=[];\n      while(previousNode){\n        shortestPathOrder.push(previousNode);\n        previousNode=previousNode.previousNode;\n      }\n      return shortestPathOrder;\n  }\n  ","import React, { Component } from 'react';\nimport Node from \"./Node/Node\";\nimport \"./PathfindingVisualizer.css\";\nimport {dijkstra,getShortestPathOrder} from \"../algorithms/dijkstra\";\n\nlet startNode_row=-1;\nlet startNode_col=-1;\nlet finishNode_row=-1;\nlet finishNode_col=-1;\n\nlet maxCol,maxRow;\nif(window.screen.width>500){\n    maxCol=50;\n}else maxCol=14;\nmaxRow=15;\n\n\nexport default class PathfindingVisualizer extends Component{\n    constructor(props){\n        super(props);\n        this.state={\n            grid:[],\n            mouseIsPressed:false,\n            startNode:-1,\n            finishNode:-1,\n            message:\"\",\n            running:false\n        }\n    }\n\n    componentDidMount(){\n        // let maxCol=window.screen.width,maxRow=window.screen.height;\n        \n        if(window.screen.width>500){\n            maxCol=50;\n        }else maxCol=14;\n        maxRow=15;\n        // if(window.screen.height>)\n        console.log(\"row\",maxRow);\n        console.log(\"col\",maxCol);\n        const grid=this.initializeGrid(maxRow,maxCol);\n        this.setState({grid:grid});\n    }\n\n    \n    handleMouseDown(row,col){\n        let {startNode,finishNode}=this.state;\n        if(startNode===-1){\n            this.setState({startNode:1});\n            startNode_row=row;\n            startNode_col=col;\n            document.getElementById(`node-${startNode_row}-${startNode_col}`).className='node node-start';\n        }else if(finishNode===-1 && startNode_row!==row && startNode_col!==col){\n            this.setState({finishNode:1});\n            finishNode_row=row;\n            finishNode_col=col;\n            document.getElementById(`node-${finishNode_row}-${finishNode_col}`).className='node node-finish';\n        }else if(!(startNode_row===row && startNode_col===col) && !(finishNode_row===row && finishNode_col===col)) {\n            \n            const newGrid=this.state.grid.slice();\n            const node=newGrid[row][col];\n            const newNode={\n                ...node,\n                isWall:!node.isWall\n            }\n            newGrid[row][col]=newNode;\n            this.setState({grid:newGrid,mouseIsPressed:true});\n        }\n        \n    }\n\n    handleMouseUp(){\n        this.setState({mouseIsPressed:false});\n    }\n\n    handleMouseEnter(row,col){\n        if(!this.state.mouseIsPressed) return;\n        else if(!(startNode_row===row && startNode_col===col) && !(finishNode_row===row && finishNode_col===col)) {\n            \n            const newGrid=this.state.grid.slice();\n            const node=newGrid[row][col];\n            const newNode={\n                ...node,\n                isWall:!node.isWall\n            }\n            newGrid[row][col]=newNode;\n            this.setState({grid:newGrid});\n        }\n    }\n\n    animateShortestPath=(nodesInShortestPath)=>{\n\n        for(let i=0;i<=nodesInShortestPath.length;i++){\n            if(i===nodesInShortestPath.length){\n                setTimeout(() => {\n                    document.getElementById(`node-${startNode_row}-${startNode_col}`).className='node node-start';\n                    \n                }, i*50);\n            }else{\n                setTimeout(() => {\n                    const node=nodesInShortestPath[i];\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                      'node node-shortest-path';\n                      \n                }, i*50);\n            }\n            \n        }\n        // setTimeout(() => {\n             \n        // }, nodesInShortestPath.length*(nodesInShortestPath.length-1)*50/2);\n        \n        document.getElementById(`node-${finishNode_row}-${finishNode_col}`).className='node node-finish';\n    }\n\n    animateDijkstra=(visitedNodesInOrder,nodesInShortestPath)=>{\n        for(let i=0;i<=visitedNodesInOrder.length;i++){\n            // if(i===visitedNodesInOrder.length){\n            //     setTimeout(()=>{\n            //         this.animateShortestPath()\n            //     })\n            // }\n            if(i===visitedNodesInOrder.length){\n\n                if(nodesInShortestPath.length===0){\n                    this.setState({message:\"Sorry, There is no way to reach destination...\"});\n                    setTimeout(() => {\n                        this.setState({message:\"\"});    \n                    }, 1000);\n                }else{\n                    setTimeout(() => {\n                        this.animateShortestPath(nodesInShortestPath);\n                    }, 10*i);\n                }\n\n                \n            }else{\n                setTimeout(() => {\n                    const node = visitedNodesInOrder[i];\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                      'node node-visited';\n                  }, 10 * i);    \n            }\n            \n            }\n    }\n\n    initializeGrid(maxRow,maxCol){\n        const grid=[];\n        for(let row=0;row<maxRow;row++){\n            const currentRow=[];\n            for(let col=0;col<maxCol;col++){\n                let currentNode={\n                    row,    // row number\n                    col,    // column number\n                    isStart:row===startNode_row && col===startNode_col,\n                    isFinish:row===finishNode_row && col===finishNode_col,\n                    distance:Infinity,\n                    isWall:false,\n                    previouNode:null,\n                    isVisited:false\n                }\n                currentRow.push(currentNode);\n            }\n            grid.push(currentRow);\n        }\n        console.log(\"sunny\");\n        return grid;\n    }\n    // onClick(row,col){\n\n    // }\n\n\n    clear=()=>{\n        if(!this.state.running){\n            // visitedNodesInOrder,nodesInShortestPath=getShortestPathOrder;\n            if(window.screen.width>500){\n                maxCol=50;\n            }else maxCol=14;\n            for(let row=0;row<15;row++){\n                for(let col=0;col<maxCol;col++){\n                    document.getElementById(`node-${row}-${col}`).className='node';\n                }\n            }\n\n            startNode_row=-1;\n            startNode_col=-1;\n            // document.getElementById(`node-${finishNode_row}-${finishNode_col}`).className='node';\n            finishNode_row=-1;\n            finishNode_col=-1;\n            const newGrid=this.initializeGrid(maxRow,maxCol);\n            console.log(\"grids\",newGrid);\n            // document.getElementById(`node-${startNode_row}-${startNode_col}`).className='node';\n            \n            this.setState({grid:newGrid,startNode:-1,finishNode:-1,message:\"\"});    \n        }else{\n            // let msg=;\n            this.setState({message:\"Algo is running, please wait ...\"});\n            setTimeout(() => {\n                this.setState({message:\"\",running:false});\n            }, 2000);\n        }\n        \n    }\n\n    visualiseDijkstra=()=>{\n        this.setState({running:true});\n        let {startNode,finishNode}=this.state;\n        if(startNode!==-1 && finishNode!==-1){\n            const {grid}=this.state;\n            const startNode=grid[startNode_row][startNode_col];\n            const finishNode=grid[finishNode_row][finishNode_col];\n            const visitedNodesInOrder=dijkstra(grid,startNode,finishNode);\n            const nodesInShortestPath=getShortestPathOrder(finishNode);\n            \n            // console.log(\"s\",nodesInShortestPath);\n            this.animateDijkstra(visitedNodesInOrder,nodesInShortestPath);\n        }else{\n            this.setState({message:\"please select starting and final point both...\"});\n            setTimeout(() => {\n                this.setState({message:\"\"});    \n            }, 2000);\n        }\n        \n    }\n\n    render(){\n        const {grid}=this.state;\n        console.log(\"grid\",this.state.grid);\n        return(\n            <div>\n                <div className=\"header\">\n                    PathFinder\n                </div>\n                <div className=\"message\">\n                    <span >by Sunny Tyagi</span>\n                    {this.state.message}\n                </div>\n                <div className=\"instruction\">\n                    1) First select the initial and final destination.<br/><br/>\n                    2) Then select the walls (optional).<br/><br/>\n                    3) Start being the \"Doraa the Explorer\".<br/><br/>\n                </div>\n                <div className=\"buttons\">\n                    <button onClick={()=>this.visualiseDijkstra()} style={{margin:\"5px\"}}>find route</button>\n                    <button onClick={()=>this.clear()} style={{margin:\"5px\"}}>clear</button>\n                </div>\n                {/* <div className=\"header\">\n                    {this.state.message}\n                </div> */}\n                <div className='grid'>\n                    {grid.map((row,rowIndx)=>{\n                        return(\n                            <div key={rowIndx}>\n                                {\n                                    row.map((node,nodeIndx)=>{\n                                        const {isStart,isFinish,isVisited,row,col,isWall}=node\n                                        return<Node \n                                                key={nodeIndx}\n                                                isStart={isStart}\n                                                isFinish={isFinish}\n                                                test={'foo'}\n                                                col={col}\n                                                isWall={isWall}\n                                                mouseIsPressed={this.state.mouseIsPressed}\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                                onMouseEnter={(row, col) =>\n                                                    this.handleMouseEnter(row, col)\n                                                }\n                                                onMouseUp={() => this.handleMouseUp()}\n                                                row={row}\n                                                isVisited={isVisited}\n                                            ></Node>\n                                    })\n                                }\n                            </div>\n                        );\n                    \n                    })}\n                </div>\n            </div>\n        )\n    }\n}","import logo from './logo.svg';\nimport './App.css';\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}